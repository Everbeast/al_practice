### tcp如何保证有序, 不丢失,不重复

> 发送方每次发送数据时,tcp给每个数据包分配一个序列号(发送方把已发送的数据包保留的缓冲区中),在略大于RTT的时间内等待接收方发送回来的序列号ACK进行确认,若没有收到ACK发送法就会重传数据包,若收到确认则释放该数据包占用的缓冲区. 
>
> 接收方收到数据包后验证校验和,若不正确则丢弃包等待超时重传过来的数据包.利用序列号保证接受数据的顺序.
>
> 接受方对比接受缓存区和数据的序列号,若发现有重复数据则将数据丢弃,并将需要请求的数据序列号做为确认号返回

UDP和TCP的特点与区别

> 1 连接
>
> - tcp是面向连接的,传输数据前要先建立连击
> - udp是不需要连接的,即可传输数据
>
> 2 服务对象
>
> - tcp是一对一的两点服务
> - udp支持一对一, 一对多, 多对多的交互通信
>
> 3 可靠性
>
> - tcp是可靠的,保证数据无差错, 不丢失, 不重复到达
> - udp是尽最大努力交付,但不保证可靠
>
> 4 拥塞控制,流量控制
>
> - tco有拥塞控制和流量控制机制,保证数据传输的安全性
> - udp没有,即使网络非常拥堵也不会影响udp的发送速率
>
> 5 首部开销
>
> - tcp首部长度较长, 没有"选项"字段时是20字节,有则会边长
> - udp首部开销较小,并且不变,只有8字节
>
> 6 传输方式
>
> - tcp是流式传输,没有边界,但保证顺序和可靠
> - udp是一个包一个包的发送,有边界,但可能丢包和乱序
>
> 分片不同
>
> - TCP 的数据⼤⼩如果⼤于 MSS ⼤⼩，则会在传输层进⾏分⽚，⽬标主机收到后，也同样在传输层 组装 TCP 数据包，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚。 
> - UDP 的数据⼤⼩如果⼤于 MTU ⼤⼩，则会在 IP 层进⾏分⽚，⽬标主机收到后，在 IP 层组装完数 据，接着再传给传输层，但是如果中途丢了⼀个分⽚，则就需要᯿传所有的数据包，这样传输效率 ⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU。
>
> ------
>
> 总结
>
> UDP :
>
> 是无连接的,尽最大可能交付(不可靠),没有拥塞控制,面向报文(对应用程序传下来的报文直接添加UDP首部,不合并不拆分),支持一对一,一对多,多对一,多对多.
>
> TCP
>
> 是面向连接的,提供可靠交付,有流量控制,拥塞控制,提供全双工通信,面向字节流(把上面传下来的报文看成字节流,若超过大小会拆分), 只能一对一的通信
>
> 应用场景:
>
> 由于 TCP 是⾯向连接，能保证数据的可靠性交付，因此经常⽤于： 
>
> - FTP ⽂件传输 
> - HTTP / HTTPS 
>
> 由于 UDP ⾯向⽆连接，它可以随时发送数据，再加上UDP本身的处理既简单⼜⾼效，因此经常⽤于：
>
> - 包总量较少的通信，如 DNS 、 SNMP 等 
> - 视频、⾳频等
> - 多媒体通信 ⼴播通信

### TCP为什么被称为流式传输协议

> tcp协议会根据接收端能接受的数据量(发送窗口),网络的拥塞程度(拥塞窗口)等情况来决定每次发送多少数据,没有固定的"报文"或"报文边界"的概念,因此读取tcp的数据就像从串行端口读取数据一样,无法预知在每次读取调用能返回多少字节
>
> 字节流：消息是「没有边界」的，所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是「有序 的」，当「前⼀个」消息没有收到的时候，即使它先收到了后⾯的字节，那么也不能扔给应⽤层去 处理，同时对「᯿复」的报⽂会⾃动丢弃。

### TCP的三次握手过程和状态变化

> ![image-20210304142928350](https://gitee.com/chillchan/images/raw/master/test/image-20210304142928350.png)
>
> 第三次握手可以携带数据,前两次不行 !

### TCP建立为什么要三次,不能是两次

> 1 无法避免旧重复连接初始化
>
> 当客户端发送旧的请求连接(seq_num = 90), 然后发送新的请求连接(seq_num = 100), 服务端先接受到旧的连接,发回客户端ack = 91,客户端新发送的需要的ack是101,因此可以判断出这个是旧连接请求的响应,因此返回RST给服务端,终止这次旧的连接.然后服务器再接收到seq_num=100的请求连接,从而进行正确的tcp简历,若是两次握手则无法判断. 
>
> 2 资源浪费
>
> 若是两次握手,客户端发送请求1 网络拥堵堵塞了,当超时重发请求2,服务端收到连接建立,返回请求数据.当请求1后面到达服务器,又建立了连接,再次发送请求数据,造成重复的消息和浪费资源分配

### TCP的四次挥手和状态变化

> ![image-20210304144603659](https://gitee.com/chillchan/images/raw/master/test/image-20210304144603659.png)
>
> 客户端打断关闭连接,发送TCP首部FIN标志位置为1的报文(然后看图说话)

### 为什么要四次挥手

> 关闭连接时,客户端发送FIN,仅表示客户端不再发送数据了,但还能接受数据
>
> 服务端接受到FIN先返回ACK,但自己可能还有数据需要处理,当服务端不再发送数据了,再发送FIN给客户端表示同意关闭连接. 因为服务端需要处理数据需要时间,因此返回的ACK和发送FIN给客户端需要分开两次,因此需要四次挥手

### 为什么TIME_WAIT等待时间是2MSL

> TIME_WAIT是从客户端收到服务端的FIN发送ACK开始计时的,此时开始,在一个1MSL中服务端没有收到最后ACK会触发超时重传,重传FIN,到达客户端(此时正好一来一回2个MSL)后,客户端重发ACK(TIME_WAIT重新计时). 直到服务器收到ACK正确关闭连接,客户端time_wait时间没收到FIN也正确关闭连接
>
> TIME_WAIT过短:
>
> - 若客户端第一次收到FIN返回的ACK没有收到,服务器重发的FIN没有得到ACK回应,服务器无法正确关闭连接
> - 若服务器返回的一个数据(设seq_num=301)在网络中遭到阻塞, 而后面均正确关闭连接,又建立新的连接,相同端口被重用后,被延迟的seq_num=301到达了客户端,这是正常接收的过期数据,会产生数据错乱

### TIME_WAIT过长会怎样

> 内存资源占用
>
> 对端口资源的占用(一个tcp至少消耗一个本地端口)

### TCP快速重传

> ![image-20210305150936612](https://gitee.com/chillchan/images/raw/master/test/image-20210305150936612.png)
>
> 看图说话(接受到ack6表示前面的都接受了)

### 流量控制解决了什么问题,怎么实现,接收窗口为0怎么办

> 流量控制使得发送方不能无脑的一直发数据给接收方,否则对方会处理不过来,导致触发重转机制等,导致网络流量的浪费,因此tcp提供一直机制让发送方根据接收方的实际接收能力控制发送的数据量.
>
> 实现:发送方有一个发送窗口,接收方有一个接收窗口,他们都是系统内存一定大小的缓冲区. 发送方会根据接收方的窗口大小和自己发送窗口的可用窗口大小取最小值来决定发送数据的长度.可用窗口 = 发送窗口 - 发送数据的长度. 若发送方收到ack,则会将缓存区的数据删除,可用窗口会增加对应长度.
>
> 接受窗口为0时:
>
> 收到0零窗口通知,发送方会阻塞,启动持续计时器,等待接收方新窗口大小通知,若等到计时器超时发送方发送窗口探测报文,从而得到新的接受窗口
>
> - 若接受窗口仍为0, 重启计时器 (一般窗口探测为3次,都为0的话可能会发送RST中断连接)
>
>   (若没有计时器,若新窗口大小报文丢失,则发送方和接收方都在相互等待,死锁 )

### 先减少缓存,再收缩窗口会怎样
> 若接收方减少缓存同时收缩窗口会出现丢包(因为可能在返回接受窗口大小还没到达对方,对方已经发出大于目前接受窗口的数据长度), 因此需要先收缩窗口,过段时间再减少缓存

网络编程socktet可读可写条件判断

https://www.cnblogs.com/wztshine/p/12088541.html

## select/poll 和 epoll

### epoll如何实现多路复用

> ![v2-ebddc2c59d9488e76e4d983252a853ee_720w](https://gitee.com/chillchan/images/raw/master/test/v2-ebddc2c59d9488e76e4d983252a853ee_720w.jpg)
>
> 调用epoll_create的,创建了一个eventpoll对象. 
>
> 通过调用epoll_ctl来添加或者删除要监听的socket,添加通过将socket句柄封装成epitem对象并添加到eventpoll对象的红黑树中
>
> 当程序执行到epoll_wait的时候,若就绪队列不为空,这立即返回, 否则则阻塞
>
> 当程序执行epoll_wait时, 若eventpoll的就绪队列不为空,这立即返回, 否则则阻塞
>
> 当socket收到数据后,中断程序会将红黑树中的对应的epitem添加到eventpoll对象的就绪列表中(通过引用添加)
>
> 然后将就绪队列的文件列表复制到epoll_wait()的events参数,唤醒阻塞在epoll_wait()的进程.(内核复制到用户态)

### select的机制

> select将要监听的socket句柄放进一个数组,将该数据从用户态赋值到内核态,让系统内核去查询这些socket是否有事件发生,然后再将这些数据复制回用户态,select返回(阻塞结束).再遍历一遍这个数组来看哪个socket事件发生变化

### select和poll 

> poll是用链表代替select中的数组,没有最大连接数限制

### select poll epoll对比

> select缺点:
>
> - 需要将整个句柄集合从用户态拷贝到内核态,轮询结束又将其拷贝回用户态,开销很大
> - 随着fd数目增加效率变低(拷贝的东西多了)
> - 支持文件描述符数量少,默认1024
>
> poll:
>
> - 没有最大连接数限制,其他和select类似
>
> epoll:
>
> - 只有事件发生了才会唤醒epoll_wait,也只会得到事件发生的描述符,和连接的总数无关,效率提高
>
> - 支持LT(水平触发)和ET(边缘触发)两种模式,上述两者都只支持LT模式
>
>   ET: fd有可读写事件,只通知一次,即使这次没有处理完,下次epoll_wait也不会通知,这样系统不会充斥大量不关心的描述符(我读着没读完我知道,不被打断就能把buffer读完,不管期间发生多少次epoll_wait)
>
>   LT: 没读完就下次都会通知你(epoll_wait返回,清空eventpoll对象的就绪队列,没读完的再添加会就绪队列)
>
> 如果连接数少的话,select/poll效率会比epoll高,因为epoll的通知机制需要多个函数的回调,以及数据结构