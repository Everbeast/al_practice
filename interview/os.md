### 用户态 和 内核态

> 内核功能:
>
> - 进程/线程管理
> - 低级存储器管理(虚拟地址到物理地址的变换)
> - 中断处理等
>
> 进程执行系统调用而进入内核态执行内核代码,成为进程处于**内核态**, 其他称为**用户态**
>
> 只有内核态能执行的指令:
>
> - I/O指令, 屏蔽指令, 清内存, 设置时钟指令等
>
> 用户态到内核态的转换:
>
> - 系统调用             | 如fork进入内核态创建新进程的内存空间等.
> - 异常                    | 如缺页
> - 外围设备的中断  | 如硬盘读写操作完成

### 什么是非阻塞io,什么是io复用

> 非阻塞io : 当调用read等接受数据,有收到数据就返回数据,没有数据就立即返回一个错误信息
>
> 阻塞io : 有就返回, 没有就阻塞 等待数据到来
>
> io复用: 使用一个线程来检查多个文件描述符的状态,如果有一个文件描述符就绪,则返回,否则就阻塞知道超时.(得到就绪状态后进行的操作,可以在同一线程里面执行,也可以启动线程执行)

### 简述进程和线程区别

> 进程是资源分配的最小单位
> 线程是资源调度的的最小单位
>
> 一个进程可以包含多个线程（一辆火车可以有多个车厢）
> 线程在进程下行进（单纯的车厢无法运行）
>
> 进程有用自己的资源空间,同一进程的多个线程共享同一进程内的资源
> 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
>
> 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
> (管道\套接字\信号交互\共享内存\消息队列等进行通信)
>
> 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
>
> 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
>
> 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
>
> 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”

### 线程有哪些自己的私有资源和共享资源

> 共享:进程代码段,公有数据,打开的文件描述符,进程当前目录,进程用户id和进程组id
>
> 私有: 线程id, 线程的堆栈(独立调用函数),信号屏蔽码(不同感兴趣的信号),优先级

### 系统给进程分配的资源

> ![image-20210305120413958](https://gitee.com/chillchan/images/raw/master/test/image-20210305120413958.png)
>
> bss : 存放未初始化的全局变量
>
> data: 存放已初始化的全局变量
>
> test : 存放执行代码

### 进程fork的时候，虚拟地址空间的五大分区哪些不需要写时复制过去？

> 在fork之后两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。即五大分区都需要写时复制
>
> 扩充:父子进程之间在刚fork后，刚刚创建子进程后:
> （1）父子相同处: 全局变量、.data、.bbs、.text、栈、堆、环境变量、用户ID、宿主目录（进程用户家目录）、进程工作目录、信号处理方式等等
> （2）父子不同处: 1.进程ID 2.fork返回值 3.父进程ID 4.进程运行时间 5.闹钟(定时器) 6.未决信号集

### 进程间的通信方式,及优缺点

> 通信方式 : 管道 消息队列 共享内存,信号量,信号,socket
>
> **管道**:
>
> 通信数据都是<u>无格式的流</u>(不支持定位) 且大小受限,单向(半双工),先进先出
>
> - 匿名管道: 只能用于存在父子关系的进程间通信.(linux命令的 | )
> - 命名管道: 可以在不存在父子关系的进程间通信.(FIFO)
>
> **消息队列**:
>
> - 克服了管道的数据是无格式的字节流,传递信息少等问题.
> - 它是存在内核中的消息链表.
> - 数据可以用户自己定义数据类型,发送时被分成独立的消息体,接收时数据类型保持一致,接收后内核会把对应的消息体删除
> - 缺电:存在用户态与内核态之间数据拷贝的开销
>
> **共享内存**:
>
> - 映射一段共享内存空间,多个进程都能直接访问,是最快的进程间通信
> - 因竞争问题会造成数据错乱,需要结合信号量才使用
> - 优点 : 解决数据在用户态和内核态之间数据拷贝的开销
>
> **信号量**:
>
> 是一个计数器,用于实现进程间的互斥与同步,而不是用于缓存进程间通信的数据
>
> 信号:
>
> 用于通知接受进程某个事件已经发生,如ctrl c
>
> **socket**:
>
> 用于不同主机上的进程间的通信

### 如何实现一个线程池

> 用vector来存放创建的线程, 维护一个工作队列, 当有任务到来,先对工作队列上锁,因为该队列被所有线程共享,然后再将任务添加到工作队列中,然后signal条件变量,释放锁.
>
> 线程的工作函数不停询问工作队列,若队列为空,则等待. 若被唤醒(被signal) 且队列不为空(while里),则取出队列的任务,线程进行任务的工作.

### 消费者生产者多线程模型中,条件变量等待为什么要在while里面

> 一个生产者可能对应多个消费者,当多个消费者都在处于cond_wait的状态,生产者插入一条数据发出signal, 可能工作队列还是空的,因为可能被其他消费者拿走了,因此需要while一直判断这个条件.若是if的话就不再判断工作队列是否为空,直接继续下去,引起错误.

### 为什么(生成者)条件变量要加锁

> 因为要保证消费者的while条件判断和调用cond_wait的原子性
>
> 否则如下:
>
> ```c++
> //thread A(消费者)
> pthread_mutex_lock(&mutex);
> while (false == ready) {
>     //(1)
>     pthread_cond_wait(&cond, &mutex);
> }
> pthread_mutex_unlock(&mutex);
> 
> //thread B(生产者)
> ready = true;
> pthread_cond_signal(&cond);
> ```
>
> 若在进入while后, cond_wait前,即(1)位置,生产者ready=true,并唤醒. 然后消费者再进去cond_wait,导致永远无法thread A永远无法唤醒
>
> 因此要保证条件判断和调用cond_wait的原子性,因此thread B也要加锁
>
> ```c++
> pthread_mutex_lock(&mutex);
> ready = true;
> pthread_cond_signal(&cond);
> pthread_mutex_unlock(&mutex);
> ```

### 先cond_signal还是先mutex_unlock

> 先cond_signal再mutex_unlock
>
> 原因: 先unlock再signal可能会导致优先级反转
>
> 1 先unlock,若另一个消费者恰好获取锁, 且条件判断队列不为空,跳过了cond_wait.这样unlock后面的signal就不起作用了(等待中的被唤醒了,队列资源都被人拿了)
>
> 2 先unlock 恰好一个优先级更低的不需要条件判断的获取锁,先执行了优先级低的线程.

### 物理内存与虚拟内存的区别,联系

> - 一个新进程建立时,建立起自己的内存空间,数据代码等拷贝到自己的进程空间.而这些内存是虚拟内存.
> - 每次访问内存空间的某个地址，都需要把地址翻译为实际物理内存地址
> -  当进程访问某个虚拟地址，去看页表.
> - 页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址(如果在的话)
> - 如果发现对应的数据不在物理内存中，则缺页异常
> - 缺页异常的处理过程，就是把进程需要的数据从磁盘上拷贝到物理内存中，如果内存已经满了，没有空地方了，那就找一个页覆盖，当然如果被覆盖的页曾经被修改过，需要将此页写回磁盘

### 什么页错误

> 页缺失（英语：Page fault，又名硬错误、硬中断、分页错误、寻页缺失、缺页中断、页故障等）指的是当软件试图访问已映射在[虚拟](https://baike.baidu.com/item/虚拟)[地址空间](https://baike.baidu.com/item/地址空间)中，但是目前并未被加载在[物理内存](https://baike.baidu.com/item/物理内存)中的一个[分页](https://baike.baidu.com/item/分页)时，由[中央处理器](https://baike.baidu.com/item/中央处理器)的[内存管理单元](https://baike.baidu.com/item/内存管理单元)所发出的[中断](https://baike.baidu.com/item/中断)。